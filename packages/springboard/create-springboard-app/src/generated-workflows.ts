// Auto-generated file - do not edit manually
// Generated from workflows YAML files

export const workflows = {
  "build_desktop_common.yml": "name: Build Tauri App\n\non:\n  workflow_call:\n    inputs:\n      platform:\n        required: true\n        type: string\n      tauri_args:\n        required: true\n        type: string\n      tauri_target:\n        required: true\n        type: string\n      # pkg_target:\n      #   required: true\n      #   type: string\n      sign_app:\n        required: true\n        type: boolean\n      target_branch:\n        required: true\n        type: string\n      profile:\n        required: true\n        type: string\n      site_url:\n        required: true\n        type: string\n      run_on_self_hosted:\n        required: false\n        type: boolean\n        default: false\n      publish_version:\n        required: false\n        type: string\n      enable_debug:\n        required: false\n        type: boolean\n        default: false\n\njobs:\n  build_tauri:\n    runs-on: \${{ (inputs.run_on_self_hosted && 'self-hosted') || inputs.platform }}\n    steps:\n    - name: Log Workflow Inputs\n      run: |\n        echo \"platform: \${{ inputs.platform }}\"\n        echo \"tauri_args: \${{ inputs.tauri_args }}\"\n        echo \"tauri_target: \${{ inputs.tauri_target }}\"\n        echo \"sign_app: \${{ inputs.sign_app }}\"\n        echo \"target_branch: \${{ inputs.target_branch }}\"\n        echo \"profile: \${{ inputs.profile }}\"\n        echo \"site_url: \${{ inputs.site_url }}\"\n        echo \"enable_debug: \${{ inputs.enable_debug }}\"\n\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        \n        \n        ref: \${{ inputs.target_branch }}\n\n    - name: Checkout releases repo into \`.github/composite-actions\`\n      uses: actions/checkout@v3\n      with:\n        repository: jamtools/releases\n        path: .github/composite-actions\n        ref: \${{ github.sha }}\n\n    \n    - name: Scaffold Springboard app\n      if: \${{ inputs.scaffold_springboard_project }}\n      run: |\n        mkdir -p apps\n        cd apps\n        npx create-springboard-app myapp --template bare\n\n- name: Build Tauri App\n      uses: ./.github/composite-actions/.github/actions/build_desktop\n      with:\n        platform: \${{ inputs.platform }}\n        tauri_args: \${{ inputs.tauri_args }}\n        tauri_target: \${{ inputs.tauri_target }}\n        sign_app: \${{ inputs.sign_app }}\n        profile: \${{ inputs.profile }}\n        site_url: \${{ inputs.site_url }}\n        apple_certificate: \${{ secrets.APPLE_CERTIFICATE }}\n        apple_certificate_password: \${{ secrets.APPLE_CERTIFICATE_PASSWORD }}\n        apple_signing_identity: \${{ secrets.APPLE_SIGNING_IDENTITY }}\n        apple_id: \${{ secrets.APPLE_ID }}\n        apple_password: \${{ secrets.APPLE_PASSWORD }}\n        apple_team_id: \${{ secrets.APPLE_TEAM_ID }}\n        github_token: \${{ secrets.GITHUB_TOKEN }}\n        enable_debug: \${{ inputs.enable_debug }}\n\n      # I need to go through the compiled tauri apps, and look at the compiled folder structure\n      # and then extract the installable for the given platform\n      # and then upload it to artifacts and S3\n    - name: Archive built artifacts\n      shell: bash\n      run: |\n        # Find all \`bundle\` directories\n        find ./apps/desktop_tauri/src-tauri/target -type d -name \"bundle\" | while read -r dir; do\n          # Extract the relative path starting after \`target/\`\n          RELATIVE_PATH=\"\${dir#./apps/desktop_tauri/src-tauri/target/}\"\n          # Copy the \`bundle\` directory to the corresponding artifacts folder\n          DEST_DIR=\"artifacts/\${{ inputs.platform }}/$(dirname \"$RELATIVE_PATH\")\"\n          mkdir -p \"$DEST_DIR\"\n          cp -r \"$dir\" \"$DEST_DIR\"\n        done\n\n    - name: Upload build artifacts\n      uses: actions/upload-artifact@v4\n      with:\n        name: tauri-build-\${{ inputs.platform }}-\${{ inputs.tauri_target }}\n        path: artifacts/\${{ inputs.platform }}\n\n    - name: Get short commit hash\n      shell: bash\n      id: commit_hash\n      run: echo \"hash=$(git rev-parse --short HEAD)\" >> $GITHUB_OUTPUT\n\n    - name: Get current datetime\n      shell: bash\n      id: datetime\n      run: echo \"value=$(date +'%Y%m%d_%H%M%S')\" >> $GITHUB_OUTPUT\n\n    - name: Extract and rename installer file\n      if: inputs.publish_version != ''\n      shell: bash\n      id: extract_installer\n      run: |\n        echo \"Starting installer file extraction for platform: \${{ inputs.platform }}\"\n\n        # Function to sanitize filename for URL compatibility (replace spaces with underscores)\n        sanitize_filename() {\n          echo \"$1\" | sed 's/[[:space:]]/_/g'\n        }\n\n        if [[ \"\${{ inputs.platform }}\" == \"macos-latest\" || \"\${{ inputs.platform }}\" == \"macos-\"* ]]; then\n          echo \"Processing macOS platform...\"\n\n          # Find DMG file with priority order\n          DMG_FILE=$(find artifacts/\${{ inputs.platform }} -name \"*.dmg\" | head -1)\n\n          echo \"Found DMG files:\"\n          find artifacts/\${{ inputs.platform }} -name \"*.dmg\" || echo \"No DMG files found\"\n\n          if [[ -z \"$DMG_FILE\" ]]; then\n            echo \"ERROR: No DMG file found in artifacts/\${{ inputs.platform }}\"\n            echo \"Available files:\"\n            find artifacts/\${{ inputs.platform }} -type f || echo \"No files found\"\n            exit 1\n          fi\n\n          echo \"Selected DMG file: $DMG_FILE\"\n\n          # Extract and sanitize the original filename\n          ORIGINAL_FILENAME=$(basename \"$DMG_FILE\" .dmg)\n          SANITIZED_FILENAME=$(sanitize_filename \"$ORIGINAL_FILENAME\")\n\n          # Create new filename: datetime_commithash_originalfilename_version.dmg\n          NEW_FILENAME=\"\${{ steps.datetime.outputs.value }}_\${{ steps.commit_hash.outputs.hash }}_\${SANITIZED_FILENAME}_\${{ inputs.publish_version }}.dmg\"\n\n          echo \"Original filename: $ORIGINAL_FILENAME\"\n          echo \"Sanitized filename: $SANITIZED_FILENAME\"\n          echo \"Final filename: $NEW_FILENAME\"\n\n        elif [[ \"\${{ inputs.platform }}\" == \"windows-latest\" || \"\${{ inputs.platform }}\" == \"windows-\"* ]]; then\n          echo \"Processing Windows platform...\"\n\n          # Find EXE file with priority order: setup files first, then any exe\n          EXE_FILE=$(find artifacts/\${{ inputs.platform }} -name \"*-setup.exe\" | head -1)\n          if [[ -z \"$EXE_FILE\" ]]; then\n            EXE_FILE=$(find artifacts/\${{ inputs.platform }} -name \"*setup*.exe\" | head -1)\n          fi\n          if [[ -z \"$EXE_FILE\" ]]; then\n            EXE_FILE=$(find artifacts/\${{ inputs.platform }} -name \"*.exe\" | head -1)\n          fi\n\n          echo \"Found EXE files:\"\n          find artifacts/\${{ inputs.platform }} -name \"*.exe\" || echo \"No EXE files found\"\n\n          if [[ -z \"$EXE_FILE\" ]]; then\n            echo \"ERROR: No EXE file found in artifacts/\${{ inputs.platform }}\"\n            echo \"Available files:\"\n            find artifacts/\${{ inputs.platform }} -type f || echo \"No files found\"\n            exit 1\n          fi\n\n          echo \"Selected EXE file: $EXE_FILE\"\n\n          # Extract and sanitize the original filename\n          ORIGINAL_FILENAME=$(basename \"$EXE_FILE\" .exe)\n          SANITIZED_FILENAME=$(sanitize_filename \"$ORIGINAL_FILENAME\")\n\n          # Create new filename: datetime_commithash_originalfilename_version.exe\n          NEW_FILENAME=\"\${{ steps.datetime.outputs.value }}_\${{ steps.commit_hash.outputs.hash }}_\${SANITIZED_FILENAME}_\${{ inputs.publish_version }}.exe\"\n\n          echo \"Original filename: $ORIGINAL_FILENAME\"\n          echo \"Sanitized filename: $SANITIZED_FILENAME\"\n          echo \"Final filename: $NEW_FILENAME\"\n\n        else\n          echo \"ERROR: Unsupported platform: \${{ inputs.platform }}\"\n          echo \"Supported platforms: macos-latest, windows-latest (and variants)\"\n          exit 1\n        fi\n\n        # Create staging directory and copy file\n        echo \"Creating staging directory...\"\n        if ! mkdir -p staging; then\n          echo \"ERROR: Failed to create staging directory\"\n          exit 1\n        fi\n\n        echo \"Copying installer file to staging...\"\n        if [[ -n \"$DMG_FILE\" ]]; then\n          SOURCE_FILE=\"$DMG_FILE\"\n        else\n          SOURCE_FILE=\"$EXE_FILE\"\n        fi\n\n        if ! cp \"$SOURCE_FILE\" \"staging/$NEW_FILENAME\"; then\n          echo \"ERROR: Failed to copy $SOURCE_FILE to staging/$NEW_FILENAME\"\n          exit 1\n        fi\n\n        echo \"Successfully created: staging/$NEW_FILENAME\"\n        ls -la \"staging/$NEW_FILENAME\"\n\n        # Set outputs\n        echo \"installer_file=staging/$NEW_FILENAME\" >> $GITHUB_OUTPUT\n        echo \"filename=$NEW_FILENAME\" >> $GITHUB_OUTPUT\n\n        echo \"Installer extraction completed successfully!\"\n\n    - name: Upload installer to S3 compatible\n      if: inputs.publish_version != ''\n      uses: shallwefootball/s3-upload-action@master\n      with:\n          aws_key_id: \${{ secrets.R2_DESKTOP_APP_KEY_ID }}\n          aws_secret_access_key: \${{ secrets.R2_DESKTOP_APP_KEY_SECRET }}\n          aws_bucket: \${{ secrets.R2_DESKTOP_APP_BUCKET }}\n          source_dir: 'staging'\n          destination_dir: 'builds/desktop'\n          endpoint: \${{ secrets.R2_DESKTOP_APP_ENDPOINT }}\n",
  "ci.yml": "name: CI\n\non:\n  push:\n    branches:\n    - '*'\n  workflow_dispatch:\n    inputs:\n      scaffold_springboard_project:\n        description: 'Whether to scaffold a new Springboard project'\n        required: false\n        default: false\n        type: boolean\n      ref:\n        description: 'Ref to use in application repo'\n        required: false\n        default: 'main'\n  repository_dispatch:\n    types: [ build-remote, new-commit-on-main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        \n        \n        \n\n    - name: Install pnpm\n      uses: pnpm/action-setup@v4\n      with:\n        version: 10.15.0\n    - name: Install Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: 20\n        cache: 'pnpm'\n    # - name: Set npm mirror\n    #   run: npm config set registry https://npmjs.cf/\n\n    - name: Install modules\n      run: npm ci\n\n    \n    - name: Scaffold Springboard app\n      if: \${{ inputs.scaffold_springboard_project }}\n      run: |\n        mkdir -p apps\n        cd apps\n        npx create-springboard-app myapp --template bare\n\n- name: Build app\n      run: npm run build\n\n    - name: Find and upload npm logs\n      if: failure()\n      run: |\n        mkdir -p artifacts/npm-logs\n        find ~/.npm/_logs -type f -name \"*.log\" -exec cp {} artifacts/npm-logs/ \\;\n      shell: bash\n    - name: Upload npm logs artifact\n      if: failure()\n      uses: actions/upload-artifact@v4\n      with:\n        name: npm-logs\n        path: artifacts/npm-logs/\n  build-docker:\n    runs-on: ubuntu-latest\n    steps:\n\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        \n        \n        \n\n    - name: Build Docker image\n      run: docker compose build\n      env:\n        PORT: 1337\n  types:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        \n        \n        \n\n    - name: Install pnpm\n      uses: pnpm/action-setup@v4\n      with:\n        version: 10.15.0\n    - name: Install Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: 20\n        cache: 'pnpm'\n    # - name: Set npm mirror\n    #   run: npm config set registry https://npmjs.cf/\n\n    - name: Install modules\n      run: npm ci\n\n    - name: Install modules for e2e tests\n      run: npm run test:e2e || echo \"No e2e tests configured\"\n\n    - name: Check Types\n      run: npm run check-types\n\n    - name: Check Types for Tests\n      run: npm run check-types:e2e || echo \"No e2e type checking configured\"\n\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        \n        \n        \n    - name: Install pnpm\n      uses: pnpm/action-setup@v4\n      with:\n        version: 10.15.0\n    - name: Install Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: 20\n        cache: 'pnpm'\n    # - name: Set npm mirror\n    #   run: npm config set registry https://npmjs.cf/\n\n    - name: Install modules\n      run: npm ci\n\n    - name: Run Tests\n      run: npm run test\n  \n\n    - name: Install modules\n      run: npm ci\n\n    - name: Install db dependencies\n      run: cd db && npm ci\n\n    - name: Generate kysely types and migrations\n      run: cd db && npm run ci\n\n      run: \n    - name: Check for uncommitted changes\n      run: |\n        if [[ -n $(git status --porcelain) ]]; then\n          echo \"Uncommitted changes for kysely client or migrations\"\n          git diff | cat\n          exit 1\n        fi\n",
  "e2e_tests.yml": "name: e2e_tests\n\non:\n  # push:\n  #   branches:\n  #   - '*'\n  workflow_dispatch:\n    inputs:\n      scaffold_springboard_project:\n        description: 'Whether to scaffold a new Springboard project'\n        required: false\n        default: false\n        type: boolean\n      ref:\n        description: 'Ref to use in application repo'\n        required: false\n        default: 'main'\n  repository_dispatch:\n    types: [ build-remote, new-commit-on-main ]\n\njobs:\n  wdio_chrome:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      with:\n        \n        \n        \n\n    - name: Checkout releases repo into \`.github/composite-actions\`\n      uses: actions/checkout@v3\n      with:\n        repository: jamtools/releases\n        path: .github/composite-actions\n        ref: \${{ github.sha }}\n\n    - name: Run WDIO tests\n      uses: ./.github/composite-actions/.github/actions/wdio_e2e\n      with:\n        browser: chrome\n"
};

export default workflows;
